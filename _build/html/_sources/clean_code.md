# Good code is for humans

Code is a set of instructions to be run by a computer. Your computer doesn’t care if your code is neat or a crazed manifesto. It doesn’t care about variable names, file lengths, or whether you jam everything into one endless line of chaos. It will just run.

*Good* code is not for computers. It's for humans. Good code guides us through its logic so that we can understand exactly what’s happening and why. It creates sensible organization so you know, immediately, what each piece is doing and where to look when it breaks.

As a researcher, you might not actually have other people read your code all that often. So maybe you don't need to worry about it being readable? No. I know one human who will definitely read your code: Future You. And Future You has a terrible memory. Future You won’t remember that tweaking the reference date also means updating line 235, or that you need to run File A, then File B, then File A again. Even if you're positive no one else will ever open your code, Future You will—and they'll resent you if it’s a mess.

Many well-meaning new programmers think that responsible coding means drowning their scripts in comments, explaining every single line as if the reader has never seen a computer before. But that’s not better! You're not gonna read all that. We’ll get into this more later, but I’m a comment minimalist. Instead of the crutch of comments, focus on structuring your code so that it speaks for itself, so it's quick to understand. Your target audience is a brilliant researcher who happens to be unfamiliar with this project's specifics. It's Future You.

Good code allows you to quickly, intuitively find things. It bundles related tasks into a single, sensibly named file telling you what’s inside. If you're not working on data-cleaning today, you don't need to look inside `data_cleaning.py`.

But good code isn't just organized; it shapes how you think about it. Good code creates abstractions that help you interact with vast, complex ideas. These abstractions can become so familiar, so obvious, that you may not even realize they needed to be invented. Tabular data ("dataframes") is one such abstraction that is so powerful you've almost certainty spent a good chunk of your life learning rules about their behavior. You know all sorts of functions to handle dataframes, and use them every day without a second thought. There are libraries upon libraries that handle data that's organized into rows and columns. That's a potent abstraction. Another abstraction is a statistical model: an object that takes in training data, optimizes some parameters, and returns a prediction function that you can use on the same or new data. As you dive deeper into engineering, you'll discover more abstractions, like "adapters" that transform outputs from one system to fit into another, making everything play nicely together.

You can start the journey to good code today. Even your first, imperfect steps will yield huge returns. Start small: organize your files, create functions and give them clear names. Before you know it, you'll naturally discover patterns in your project, and wrap them into more complex abstractions. Soon, you’ll begin to think of these patterns as functional building blocks, to be reasoned about themselves, instead of just lines of code.
